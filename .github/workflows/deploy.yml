# This workflow builds and deploys the demo-ui to AWS App Runner
# It uses runtime configuration - different configs for prod/dev baked into the image at build time
# Customer instances can use the same image with volume-mounted custom configs

name: Deploy Demo to AWS

on:
  push:
    branches:
      - main  # Production
      - dev   # Development

# Permissions needed for OIDC to work
permissions:
  id-token: write
  contents: read

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    environment:
      name: ${{ (github.ref == 'refs/heads/main' && 'Production') || 'Development' }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          aws-region: eu-central-1

      - name: Prepare environment-specific config
        run: |
          # Environment is automatically selected based on branch
          # Variables are scoped to the environment (no need for PROD_/DEV_ prefix)
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            ENV="production"
          else
            ENV="development"
          fi
          
          FLOOR_WIDTH="${{ vars.FLOOR_WIDTH }}"
          FLOOR_LENGTH="${{ vars.FLOOR_LENGTH }}"
          LOAD_DATA="${{ vars.LOAD_INITIAL_DATA }}"
          FENCES='${{ vars.FENCES }}'
          ZONE_POSITION='${{ vars.ZONE_POSITION }}'
          GCP='${{ vars.GROUND_CONTROL_POINTS }}'
          
          # Authentication settings (optional)
          # Handle proper JSON formatting for strings vs null
          if [ -n "${{ secrets.UI_PASSWORD }}" ]; then
            UI_PASSWORD="\"${{ secrets.UI_PASSWORD }}\""
          else
            UI_PASSWORD="null"
          fi
          
          if [ -n "${{ secrets.API_TOKEN }}" ]; then
            API_TOKEN="\"${{ secrets.API_TOKEN }}\""
          else
            API_TOKEN="null"
          fi
          
          SESSION_HOURS="${{ vars.SESSION_DURATION_HOURS || '720' }}"
          
          echo "üîß Building for $ENV environment"
          echo "üìê Floor: ${FLOOR_WIDTH}m x ${FLOOR_LENGTH}m"
          
          # Create environment-specific config from GitHub variables
          cat > config/default-config.json <<EOF
          {
            "floor": {
              "width": ${FLOOR_WIDTH},
              "length": ${FLOOR_LENGTH}
            },
            "zone": {
              "id": null,
              "position": ${ZONE_POSITION},
              "groundControlPoints": ${GCP}
            },
            "fences": ${FENCES},
            "initialData": {
              "loadInitialData": ${LOAD_DATA},
              "providers": [
                {"id":"provider-uwb-001","type":"uwb","name":"UWB Tag 1"},
                {"id":"provider-ble-001","type":"ble-aoa","name":"BLE Tag 1"}
              ],
              "trackables": [
                {"id":"trackable-asset-001","type":"omlox","name":"Asset #001","location_providers":["provider-uwb-001","provider-ble-001"]}
              ],
              "locations": {
                "provider-uwb-001": {"position":{"type":"Point","coordinates":[10,20]},"source":"demo-zone","provider_type":"uwb","provider_id":"provider-uwb-001","crs":"local","floor":0,"accuracy":0.5,"trackables":["trackable-asset-001"]},
                "provider-ble-001": {"position":{"type":"Point","coordinates":[30,20]},"source":"demo-zone","provider_type":"ble-mesh","provider_id":"provider-ble-001","crs":"local","floor":0,"accuracy":1.5,"trackables":["trackable-asset-001"]},
                "trackable-asset-001": {"position":{"type":"Point","coordinates":[5,5]},"source":"demo-zone","provider_type":"uwb","provider_id":"provider-uwb-001","crs":"local","floor":0,"accuracy":0.5}
              }
            },
            "auth": {
              "uiPassword": ${UI_PASSWORD},
              "apiToken": ${API_TOKEN},
              "sessionDurationHours": ${SESSION_HOURS}
            }
          }
          EOF
          
          # Validate JSON
          echo "üìã Validating config JSON..."
          cat config/default-config.json | jq . > /dev/null || exit 1
          echo "‚úÖ Config validated for $ENV"

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push Docker image to ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ vars.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          # Extract version from package.json
          APP_VERSION=$(cat package.json | jq -r '.version')
          
          # Determine semantic tag based on branch
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            SEMANTIC_TAG="latest"
            ENV_TAG="prod"
            VERSION_TAG="v${APP_VERSION}"
            echo "üè∑Ô∏è  Building image with tags: $IMAGE_TAG, $SEMANTIC_TAG, $ENV_TAG, $VERSION_TAG"
          else
            SEMANTIC_TAG="dev"
            ENV_TAG="dev"
            VERSION_TAG=""
            echo "üè∑Ô∏è  Building image with tags: $IMAGE_TAG, $SEMANTIC_TAG, $ENV_TAG"
          fi
          
          # Build with environment-specific config and version info baked in
          docker build \
            --build-arg VITE_BUILD_NUMBER="${{ github.sha }}" \
            --build-arg VITE_BUILD_TIME="$(date -u +"%Y-%m-%dT%H:%M:%SZ")" \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          
          # Tag for easy reference
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:$SEMANTIC_TAG
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:$ENV_TAG
          
          # Add version tag for production (main branch)
          if [ -n "$VERSION_TAG" ]; then
            docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:$VERSION_TAG
          fi
          
          # Push all tags
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$SEMANTIC_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$ENV_TAG
          
          # Push version tag for production
          if [ -n "$VERSION_TAG" ]; then
            docker push $ECR_REGISTRY/$ECR_REPOSITORY:$VERSION_TAG
            echo "‚úÖ Version tag pushed: $VERSION_TAG"
          fi
          
          echo "IMAGE_URI=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_ENV
          echo "‚úÖ Images pushed to ECR"

      - name: Restore default config (cleanup)
        if: always()
        run: |
          git checkout config/default-config.json

      # Deployment to App Runner - Only for dev environment
      # Production uses the Docker image directly (deployed elsewhere or on-prem)
      - name: Deploy to AWS App Runner (Dev only)
        if: github.ref == 'refs/heads/dev'
        run: |
          echo "üöÄ Deploying to App Runner (Development)..."
          
          # Wait for App Runner to be ready (max 5 minutes)
          MAX_ATTEMPTS=10
          ATTEMPT=0
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            STATUS=$(aws apprunner describe-service \
              --service-arn ${{ vars.APP_RUNNER_SERVICE_ARN }} \
              --query 'Service.Status' --output text \
              --region eu-central-1)
            
            echo "üìä App Runner status: $STATUS"
            
            if [ "$STATUS" = "RUNNING" ]; then
              break
            fi
            
            ATTEMPT=$((ATTEMPT + 1))
            if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
              echo "‚è≥ Waiting 30s for App Runner to be ready... (attempt $ATTEMPT/$MAX_ATTEMPTS)"
              sleep 30
            fi
          done
          
          if [ "$STATUS" != "RUNNING" ]; then
            echo "‚ö†Ô∏è App Runner not ready after waiting, attempting update anyway..."
          fi
          
          aws apprunner update-service \
            --service-arn ${{ vars.APP_RUNNER_SERVICE_ARN }} \
            --source-configuration "ImageRepository={ImageIdentifier=${{ env.IMAGE_URI }},ImageRepositoryType=ECR,ImageConfiguration={Port=80}}" \
            --region eu-central-1

      # Production deployment disabled - Docker image is built and pushed with 'latest' tag
      # To deploy production: Use the 'latest' tagged image from ECR manually
      # - name: Deploy to AWS App Runner (Production)
      #   if: github.ref == 'refs/heads/main'
      #   run: |
      #     echo "üöÄ Deploying to App Runner (Production)..."
      #     aws apprunner update-service \
      #       --service-arn ${{ secrets.PROD_APP_RUNNER_SERVICE_ARN }} \
      #       --source-configuration "ImageRepository={ImageIdentifier=${{ env.IMAGE_URI }},ImageRepositoryType=ECR,ImageConfiguration={Port=80}}" \
      #       --region eu-central-1

